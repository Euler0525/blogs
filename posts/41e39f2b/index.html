<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>内存管理 | 科海拾零</title><meta name="author" content="Euler0525"><meta name="copyright" content="Euler0525"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文内容基于 glibc-2.43 版本  内存分配 64 位 Linux 内存布局如下图所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 64-bit Linux (x86_64) Userspace Virtual Memory">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="https://blog.euler0525.cn/posts/41e39f2b/index.html">
<meta property="og:site_name" content="科海拾零">
<meta property="og:description" content="本文内容基于 glibc-2.43 版本  内存分配 64 位 Linux 内存布局如下图所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 64-bit Linux (x86_64) Userspace Virtual Memory">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.xsot.cn/bing?jump=true">
<meta property="article:published_time" content="2026-02-12T06:10:43.000Z">
<meta property="article:modified_time" content="2026-02-15T04:38:49.702Z">
<meta property="article:author" content="Euler0525">
<meta property="article:tag" content="内存">
<meta property="article:tag" content="堆栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.xsot.cn/bing?jump=true"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.euler0525.cn/posts/41e39f2b/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-15 12:38:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><meta name="generator" content="Hexo 7.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="科海拾零" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">113</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 页面</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-heart"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.xsot.cn/bing?jump=true')"><nav id="nav"><span id="blog-info"><a href="/" title="科海拾零"><span class="site-name">科海拾零</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 页面</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-heart"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-12T06:10:43.000Z" title="发表于 2026-02-12 14:10:43">2026-02-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-15T04:38:49.702Z" title="更新于 2026-02-15 12:38:49">2026-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/41e39f2b/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文内容基于 glibc-2.43 版本</p>
</blockquote>
<h2 id="内存分配">内存分配</h2>
<p>64 位 Linux 内存布局如下图所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">64-bit Linux (x86_64) Userspace Virtual Memory Layout</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   High addresses</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0xffffffffffffffff  +---------------------------------------------------+</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |              (non-canonical / guard)              |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0xffff800000000000  +---------------------------------------------------+</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |                  Kernel space                     |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |   direct map, vmalloc, modules, kernel text, ...  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |   (not accessible from user mode)                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0x0000800000000000  +---------------------------------------------------+</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |              (non-canonical / hole)               |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0x00007fffffffffff  +---------------------------------------------------+</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |                User space (canonical)             |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |                                                   |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  [stack]  grows down                              |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |      |                                            |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |      v                                            |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  |           Stack              |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  |  argv/envp/auxv (startup)    |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |                                                   |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  (mmap region: shared libs, anon mmaps, files)    |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  |   libc.so / ld-linux.so      |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  |   other .so, mapped files    |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  |   anonymous mappings         |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |           ^                                       |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |           |  grows down (typical)                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |                                                   |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  [heap]  grows up                                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |      ^                                            |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |      |                                            |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  |            Heap              |  (brk/sbrk)     |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |                                                   |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  | .bss (zero-inited)           |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  | .data (inited)               |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  | .rodata                      |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  | .text (code)                 |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  +------------------------------+                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |  | ELF header / program headers |                 |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0x0000000000400000  +--+------------------------------+-----------------+</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                      |   (PIE main exe may be randomized elsewhere)      |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0x0000000000000000  +---------------------------------------------------+</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Low addresses</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Notes:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- Addresses are approximate; ASLR randomizes stack, mmap base, and PIE executables.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- x86_64 uses <span class="string">"canonical"</span> addresses (typically 48-bit, newer CPUs support 57-bit w/ 5-level paging).</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- Kernel/user <span class="built_in">split</span> shown is a common layout; exact boundaries differ by config.</span></span><br></pre></td></tr></table></figure>
<p>在编写 C/C++程序时，往往需要动态分配内存，现代内存分配器同时管理 heap
空间和 mmap 空间，位置关系如上图所示，简单地说，<code>malloc</code>
背后小块分配 heap，大块分配 mmap（参考 <a target="_blank" rel="noopener" href="https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L3807"><code>malloc.c</code>
源代码</a>）</p>
<p>简单的内存分配器运行原理如下（仅考虑堆空间）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Low addresses                         High addresses</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">| [chunk A] [chunk B] [chunk C] ...                   |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 chunk pointer(start address)</span><br><span class="line">                       |</span><br><span class="line">                       v</span><br><span class="line">+----------------------+---------------------------+</span><br><span class="line">| header               | user data                 |</span><br><span class="line">+----------------------+---------------------------+</span><br><span class="line">| size | flags | next  |  ...... payload ......   |</span><br><span class="line">+----------------------+---------------------------+</span><br><span class="line">  ^        ^      ^</span><br><span class="line">  |        |      +-- Points to the next free chunk in the free list</span><br><span class="line">  |        +--------- e.g.: flags such as whether the chunk is in use (inuse)</span><br><span class="line">  +------------------ Total size of the chunk (including header + payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Free List Structure</span><br><span class="line">free_head</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">+----------+     +----------+     +----------+</span><br><span class="line">| chunk X  | --&gt; | chunk Y  | --&gt; | chunk Z  | --&gt; NULL</span><br><span class="line">+----------+     +----------+     +----------+</span><br></pre></td></tr></table></figure>
<p><code>malloc</code> 的基本动作在 Free List 里找</p>
<ul>
<li>遍历 Free List：找到 size 足够的 chunk</li>
<li>标记为 inuse，并返回 &amp;chunk-&gt; user_data</li>
</ul>
<p><code>free(p)</code> 的基本动作把 chunk 放回 Free List</p>
<ul>
<li>通过 p 回到 chunk header（p 减去 header 大小）</li>
<li>标记为 free，并插入 Free List</li>
</ul>
<p>这样的运行机制，<code>malloc</code> 和 <code>free</code>
都需要遍历链表，效率较低 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>，而且频繁地进行 <code>malloc</code>
和 <code>free</code> 操作，容易造成内存碎片，浪费内存。</p>
<h2 id="ptmalloc-运行机制">ptmalloc 运行机制</h2>
<p>ptmalloc 是 GNU C Library (glibc) 中默认的内存分配器，它基于 Doug Lea
的 dlmalloc 实现，并针对多线程环境进行了扩展。</p>
<p>其设计核心在于</p>
<ul>
<li>减少系统调用次数，加快内存分配和释放速度；</li>
<li>通过内存合并和复用，降低内存碎片化程度；</li>
<li>支持多线程并发分配，避免锁竞争；</li>
</ul>
<h3 id="数据结构">数据结构</h3>
<p>ptmalloc 采用三级管理结构，分别为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────</span><br><span class="line">│  第1层: Arena（线程内存区）</span><br><span class="line">│  └── 管理多个 Heap，含独立锁(mutex) </span><br><span class="line">├───────────────────────────────────────</span><br><span class="line">│  第2层: Heap（堆）</span><br><span class="line">│  └── 通过 brk 或 mmap 获得的连续内存区域</span><br><span class="line">├───────────────────────────────────────</span><br><span class="line">│  第3层: Chunk（内存块）</span><br><span class="line">│  └── 实际分配/释放的最小单元</span><br><span class="line">└───────────────────────────────────────</span><br></pre></td></tr></table></figure>
<h4 id="内存块malloc_chunk">内存块(malloc_chunk)</h4>
<p>ptmalloc 将堆内存划分为 chunk，使用 <code>malloc_chunk</code>
数据结构描述（参考 <a target="_blank" rel="noopener" href="https://github.com/bminor/glibc/blob/master/malloc/malloc.c#L1083"><code>malloc.c</code>
源代码</a>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> {</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag' method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Size of chunk, in bytes                     |A|M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">	    .                                                               .</span></span><br><span class="line"><span class="comment">	    .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">	    .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             (size of chunk, but used for application data)    |</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Size of next chunk, in bytes                |A|0|1|</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where "chunk" is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but "mem" is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  "Nextchunk" is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Size of previous chunk, if unallocated (P clear)  |</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:' |             Size of chunk, in bytes                     |A|0|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">	    .                                                               .</span></span><br><span class="line"><span class="comment">	    .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">	    |             Size of next chunk, in bytes                |A|0|0|</span></span><br><span class="line"><span class="comment">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,</span></span><br><span class="line"><span class="comment">    main arena, described by the main_arena variable.  When additional</span></span><br><span class="line"><span class="comment">    threads are spawned, each thread receives its own arena (up to a</span></span><br><span class="line"><span class="comment">    configurable limit, after which arenas are reused for multiple</span></span><br><span class="line"><span class="comment">    threads), and the chunks in these arenas have the A bit set.  To</span></span><br><span class="line"><span class="comment">    find the arena for a chunk on such a non-main arena, heap_for_ptr</span></span><br><span class="line"><span class="comment">    performs a bit mask operation and indirection through the ar_ptr</span></span><br><span class="line"><span class="comment">    member of the per-heap header heap_info (see arena.c).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot' of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top' doesn't bother using the</span></span><br><span class="line"><span class="comment">	trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">	that would have to index off it. After initialization, `top'</span></span><br><span class="line"><span class="comment">	is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">	MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">	bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">	allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">	field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">	(because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">	to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">	originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">	hooks.c.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>关键字段说明如下</p>
<ul>
<li><code>mchunk_prev_size</code>：仅当前一个物理相邻的 chunk
为空闲时，该字段才有效，表示前一个 chunk 的大小；若前一个 chunk
已分配，则该字段被前一个 chunk 复用为用户数据区；</li>
<li><code>mchunk_size</code>：表示当前 chunk 的大小（包括 chunk
头部），低 3 位用作标志位
<ul>
<li><code>P (PREV_INUSE)</code>：第 0 位，表示前一个 chunk
是否在使用中（1 = 已分配，0 = 空闲）；</li>
<li><code>M (IS_MMAPPED)</code>：第 1 位，表示该 chunk 是否通过 mmap
分配（1 = mmap，0 = 堆内存）；</li>
<li><code>N (NON_MAIN_ARENA)</code>：第 2 位，表示该 chunk 是否属于非主
arena（1 = 非主 arena，0 = 主 arena）；</li>
</ul></li>
<li><code>fd/bk</code>：仅当 chunk 空闲时有效，用于将空闲 chunk
链接到双向链表 Bins 中。</li>
</ul>
<h4 id="空闲链表bins">空闲链表(Bins)</h4>
<p>为了加快分配速度，ptmalloc 使用多种 bins 管理不同大小的空闲
chunk，分别为
<code>Fast Bins, Unsorted Bins, Small Bins, Large Bins</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────</span><br><span class="line">│  Fast Bins (fastbins)</span><br><span class="line">│  ├── 数量: 10 个 (索引 0-9) </span><br><span class="line">│  ├── 大小: 16, 24, 32, 40, 48, 56, 64, 72, 80, 88 字节</span><br><span class="line">│  └── 特性: 管理小内存；LIFO单链表；不合并相邻空闲块，分配/释放速度快</span><br><span class="line">├───────────────────────────────────────────────────────</span><br><span class="line">│  Unsorted Bin (unsorted bin) </span><br><span class="line">│  ├── 数量: 1 个</span><br><span class="line">│  └── 特性: 释放后的 chunk 首先放入这里，"缓存"机制（局部性原理）</span><br><span class="line">├───────────────────────────────────────────────────────</span><br><span class="line">│  Small Bins (smallbins)</span><br><span class="line">│  ├── 数量: 62 个 (索引 2-63)</span><br><span class="line">│  ├── 大小: 16, 24, ..., 504 字节 (间隔8字节)</span><br><span class="line">│  └── 特性: FIFO循环双向链表，自动合并</span><br><span class="line">├───────────────────────────────────────────────────────</span><br><span class="line">│  Large Bins (largebins)</span><br><span class="line">│  ├── 数量: 64 个 (索引 64-127)</span><br><span class="line">│  ├── 大小: 512+ 字节，非均匀分布</span><br><span class="line">│  │   512-1024: 64字节间隔, 1024-2048: 128字节间隔...</span><br><span class="line">│  └── 特性: 双向链表，按大小排序，支持 best-fit</span><br><span class="line">└────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<p>位于堆顶部的 chunk 特殊标记为 Top Chunk，当所有的 bins
中都找不到合适的 chunk 时，ptmalloc 会尝试从 Top Chunk
中分配内存，如果内存不足，ptmalloc 会通过 <code>sbrk()</code> 扩展堆（主
arena）或创建新的 heap（非主 arena）</p>
<h4 id="线程内存区arena">线程内存区(Arena)</h4>
<p>为了支持多线程，ptmalloc 引入 arena</p>
<ul>
<li>主 arena：启动进程时创建，使用 <code>sbrk()</code> 管理内存；</li>
<li>非主 arena：当多线程并发分配时，ptmalloc 会创建多个非主 arena，每个
arena 使用 <code>mmap()</code> 分配独立的内存池；</li>
</ul>
<p>当每个线程首次分配内存时，会绑定到一个 arena，后续分配/释放在该 arena
中进行，减少锁竞争。</p>
<h3 id="内存分配流程">内存分配流程</h3>
<p>当调用 <code>malloc(size)</code> 函数分配内存时，调用的是
<code>malloc.c</code> 文件中的 <code>__libc_malloc</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> IS_IN (libc)</span></span><br><span class="line">weak_alias (__malloc_info, malloc_info)</span><br><span class="line"></span><br><span class="line">strong_alias (__libc_calloc, __calloc) weak_alias (__libc_calloc, <span class="built_in">calloc</span>)</span><br><span class="line">strong_alias (__libc_free, __free) strong_alias (__libc_free, <span class="built_in">free</span>)</span><br><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br><span class="line">strong_alias (__libc_memalign, __memalign)</span><br><span class="line">weak_alias (__libc_memalign, memalign)</span><br><span class="line">strong_alias (__libc_realloc, __realloc) strong_alias (__libc_realloc, <span class="built_in">realloc</span>)</span><br><span class="line">strong_alias (__libc_valloc, __valloc) weak_alias (__libc_valloc, valloc)</span><br><span class="line">strong_alias (__libc_pvalloc, __pvalloc) weak_alias (__libc_pvalloc, pvalloc)</span><br><span class="line">strong_alias (__libc_mallinfo, __mallinfo)</span><br><span class="line">weak_alias (__libc_mallinfo, mallinfo)</span><br><span class="line">strong_alias (__libc_mallinfo2, __mallinfo2)</span><br><span class="line">weak_alias (__libc_mallinfo2, mallinfo2)</span><br><span class="line">strong_alias (__libc_mallopt, __mallopt) weak_alias (__libc_mallopt, mallopt)</span><br><span class="line"></span><br><span class="line">weak_alias (__malloc_stats, malloc_stats)</span><br><span class="line">weak_alias (__malloc_usable_size, malloc_usable_size)</span><br><span class="line">weak_alias (__malloc_trim, malloc_trim)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">malloc(size) 调用流程：</span><br><span class="line">│</span><br><span class="line">├─ 1. 转换请求大小为 chunk 大小</span><br><span class="line">│   └─ 将请求大小向上对齐到 `CHUNK_HDR_SZ`，确保 chunk 地址对齐到 8/16 字节 + 头部开销</span><br><span class="line">│</span><br><span class="line">├─ 2. 判断大小范围</span><br><span class="line">│   │</span><br><span class="line">│   ├─ ≤ MAX_FAST_SIZE (88字节): Fast Bin 路径</span><br><span class="line">│   │   └─ 从对应 fastbin 取第一个 chunk，返回</span><br><span class="line">│   │</span><br><span class="line">│   ├─ ≤ MIN_LARGE_SIZE (512字节): Small Bin 路径</span><br><span class="line">│   │   └─ 从对应 smallbin 取 chunk（FIFO）</span><br><span class="line">│   │</span><br><span class="line">│   ├─ ≤ 128KB (默认): Large Bin 路径</span><br><span class="line">│   │   └─ 遍历 unsorted bin → 排序到 bins → best-fit 查找</span><br><span class="line">│   │</span><br><span class="line">│   └─ &gt; 128KB: 直接 mmap 分配</span><br><span class="line">│       └─ 独立匿名映射，单独管理，munmap 释放</span><br><span class="line">│</span><br><span class="line">├─ 3. 如果 bins 中无合适 chunk</span><br><span class="line">│   └─ 使用 Top Chunk（arena 顶部的剩余空间）</span><br><span class="line">│       └─ 如果 Top Chunk 不够 → 扩展堆（brk/mmap）</span><br><span class="line">│</span><br><span class="line">└─ 4. 切割 chunk（如果需要）</span><br><span class="line">    └─ 剩余部分形成新的空闲 chunk，放入 unsorted bin</span><br></pre></td></tr></table></figure>
<h3 id="内存回收流程">内存回收流程</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">free(ptr) 调用流程：</span><br><span class="line">│</span><br><span class="line">├─ 1. 检查 ptr 有效性（非NULL、对齐、在堆范围内）</span><br><span class="line">│</span><br><span class="line">├─ 2. 获取 chunk 指针和 arena</span><br><span class="line">│   └─ mem2chunk(ptr) → chunk; arena_for_chunk(chunk)</span><br><span class="line">│</span><br><span class="line">├─ 3. 判断 chunk 类型</span><br><span class="line">│   │</span><br><span class="line">│   ├─ IS_MMAPPED: 直接 munmap 释放</span><br><span class="line">│   │</span><br><span class="line">│   └─ 普通 chunk:</span><br><span class="line">│       ├─ 检查相邻 chunk 是否空闲（合并）</span><br><span class="line">│       │   └─ 前一 chunk 空闲: 合并到前一个</span><br><span class="line">│       │   └─ 后一 chunk 空闲: 合并到当前</span><br><span class="line">│       │</span><br><span class="line">│       ├─ 判断合并后大小</span><br><span class="line">│       │   ├─ ≤ MAX_FAST_SIZE: 放入 fast bin（不合并时）</span><br><span class="line">│       │   └─ &gt; MAX_FAST_SIZE: 放入 unsorted bin</span><br><span class="line">│       │</span><br><span class="line">│       └─ 尝试向后合并 top chunk</span><br><span class="line">│           └─ 如果相邻 top chunk，合并到 top chunk</span><br><span class="line">│</span><br><span class="line">└─ 4. 触发 malloc_consolidate（特定条件）</span><br><span class="line">    └─ 将 fast bins 中的 chunk 合并并移入 unsorted bin</span><br></pre></td></tr></table></figure>
<h3 id="线程缓存tcache---glibc-2.26">线程缓存(Tcache - glibc 2.26+)</h3>
<h2 id="参考资料">参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/glibc/">The GNU C Library
(glibc)</a></p>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/git/glibc.git">glibc.git</a></p>
<p><a target="_blank" rel="noopener" href="http://manistein.club/post/program/c/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ptmalloc%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6/">深入理解
ptmalloc 的运作机制</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/initphp/category_10542242.html">ptmalloc
源码分析</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.euler0525.cn">Euler0525</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.euler0525.cn/posts/41e39f2b/">https://blog.euler0525.cn/posts/41e39f2b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.euler0525.cn" target="_blank">科海拾零</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98/">内存</a><a class="post-meta__tags" href="/tags/%E5%A0%86%E6%A0%88/">堆栈</a></div><div class="post_share"><div class="social-share" data-image="https://api.xsot.cn/bing?jump=true" data-sites="wechat, qq, weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f5398568/" title="Nginx学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.xsot.cn/bing?jump=true" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/d67f9042/" title="为什么是50Ω"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.xsot.cn/bing?jump=true" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">为什么是50Ω</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ptmalloc-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">ptmalloc 运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9D%97malloc_chunk"><span class="toc-number">2.1.1.</span> <span class="toc-text">内存块(malloc_chunk)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8bins"><span class="toc-number">2.1.2.</span> <span class="toc-text">空闲链表(Bins)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%8C%BAarena"><span class="toc-number">2.1.3.</span> <span class="toc-text">线程内存区(Arena)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">内存分配流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">内存回收流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98tcache---glibc-2.26"><span class="toc-number">2.4.</span> <span class="toc-text">线程缓存(Tcache - glibc 2.26+)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2026 By Euler0525</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23lioMo7LF5urlkKZI',
      clientSecret: 'dceac52a81d3a5702ab3eeeb3763babe336d27ae',
      repo: 'blogs',
      owner: 'Euler0525',
      admin: ['Euler0525'],
      id: '21d7bda6f121e5158adc8f20184dde61',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>