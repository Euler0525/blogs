---
title: 多线程编程
tags:
  - 线程
  - 操作系统
categories: 编程
mathjax: true
abbrlink: 341a9d02
date: 2024-10-12 15:39:59
---

# 多线程编程（C语言版）

> C语言中使用`pthread`库进行多线程编程。

## 创建线程

- `pthread_t`用于声明线程ID；

---

```c
/* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  */
extern int pthread_create (pthread_t *__restrict __newthread,
			   const pthread_attr_t *__restrict __attr,
			   void *(*__start_routine) (void *),
			   void *__restrict __arg) __THROWNL __nonnull ((1, 3));
```

`pthread_create`函数使用线程ID创建一个线程，包含四个参数：**线程ID**、**线程属性**、**函数指针**、**参数指针**

- 线程ID类型为`pthread_t *`，因此在传递时需要对线程ID取地址；
- 线程属性无特殊要求使用N`ULL`即可，也可以自定义线程的栈大小、调度优先级等；
- 线程函数类型为`void *`，函数名本身就可以表示函数地址，传递时直接使用函数名即可，并且**函数的返回值必须为`void *`**；
- 参数指针必须为`void *`类型，没有参数时传递`NULL`即可；

函数返回值`0`表示线程创建成功，`!0`表示失败

- `EAGAIN`：系统资源不足；
- `EINVAL`：传递的`attr`参数无效
- `EPERM`：属性设置非法，或者没有设置权限

---

```c
/* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.
 
   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_join (pthread_t __th, void **__thread_return);
```

`pthread_join`函数用于等待一个线程返回，并且获取其返回值。包括两个参数**线程名**和**接收返回值的指针**。函数返回`0`表示等待成功，`!0`表示等待失败。

示例代码如下

```c
#include <malloc.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

pthread_t sub_thread_id;

void *sub_thread(void *arg) {
    char *info = (char *)arg;
    sleep(1);
    int ret = printf("%s ", info);
    if (ret > 0) {
        printf("Successfully!\n");
        return (void *)"OK";
    } else {
        printf("Failed!\n");
        return (void *)"ERROR";
    }
}

int main(int argc, char **argv) {
    char *info = "Child Thread~";
    int ret = pthread_create(&sub_thread_id, NULL, sub_thread, (void *)info);
    if (ret) {
        printf("Create child thread failed, return %d.\n", ret);
    } else {
        printf("Create child thread successfully.\n");
    }

    printf("Continue...\n");

    char *result = (char *)malloc(10);
    if (result == NULL) {
        printf("Out of Mem!\n");
        return -1;
    }
    pthread_join(sub_thread_id, (void *)(&result));
    printf("Child thread end : %s \n", result);

    return 0;
}
```

## 示例分析

### `main-race`

```c
#include "mythreads.h"
#include <stdio.h>

int balance = 0;

void *worker(void *arg) {
    balance++; // unprotected access

    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    Pthread_create(&p, NULL, worker, NULL);
    balance++; // unprotected access
    Pthread_join(p, NULL);

    return 0;
}
```

- `helgrind`工具分析结果如下（省略部分无用信息）

```shell
❯ valgrind --tool=helgrind ./main-race
==23772== Command: ./main-race
==23772== 
==23772== ---Thread-Announcement------------------------------------------
==23772== 
==23772== Thread #1 is the program's root thread
==23772== 
==23772== ---Thread-Announcement------------------------------------------
==23772== 
==23772== Thread #2 was created
==23772==    at 0x49979F3: clone (clone.S:76)
==23772==    by 0x49988EE: __clone_internal (clone-internal.c:83)
==23772==    by 0x49066D8: create_thread (pthread_create.c:295)
==23772==    by 0x49071FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==23772==    by 0x48572A6: pthread_create_WRK (hg_intercepts.c:445)
==23772==    by 0x4858BB2: pthread_create@* (hg_intercepts.c:478)
==23772==    by 0x109564: Pthread_create (mythreads.h:49)
==23772==    by 0x109654: main (main-race.c:16)
```
由上面输出信息可知程序有一个**主线程#1**和一个**由程序创建的子线程#2**。

```shell
==23772== Possible data race during read of size 4 at 0x10C014 by thread #1
==23772== Locks held: none
==23772==    at 0x109655: main (main-race.c:17)
==23772== 
==23772== This conflicts with a previous write of size 4 by thread #2
==23772== Locks held: none
==23772==    at 0x109609: worker (main-race.c:10)
==23772==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==23772==    by 0x4906AC2: start_thread (pthread_create.c:442)
==23772==    by 0x4997A03: clone (clone.S:100)
==23772==  Address 0x10c014 is 0 bytes inside data symbol "balance"
```

这部分内容说明程序运行时可能存在数据竞争，线程#1在地址`0x10C014`处进行了一次4字节的读取操作，对应`main-race.c`文件的第17行`main`函数中的` balance++; // unprotected access`，发生数据竞争的原因是这次读取与线程#2之前在同一地址处的写入操作存在冲突。对应`main-race.c`文件的第10行`worker`函数中的`balance++; // unprotected access`

```shell
==23772== Possible data race during write of size 4 at 0x10C014 by thread #1
==23772== Locks held: none
==23772==    at 0x10965E: main (main-race.c:17)
==23772== 
==23772== This conflicts with a previous write of size 4 by thread #2
==23772== Locks held: none
==23772==    at 0x109609: worker (main-race.c:10)
==23772==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==23772==    by 0x4906AC2: start_thread (pthread_create.c:442)
==23772==    by 0x4997A03: clone (clone.S:100)
==23772==  Address 0x10c014 is 0 bytes inside data symbol "balance"
```

`main`函数中的`balance++`既要读取又要修改该变量，因此`helgrind`工具还检测到线程#1在地址`0x10C014`处进行了一次写入操作，这也可能存在数据竞争。

```shell
==23772== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
```

综上，该程序中存在两个数据竞争问题。在多线程环境中，`balance`这个共享资源没有适当的同步机制（如互斥锁）来保护其访问。因此，当两个线程尝试同时访问（读取或写入）这个变量时，就可能发生数据竞争，导致数据损坏或不一致的结果。

---

下面尝试修改这段代码：

1. 当删除主线程或子线程中的`balance++`时，不存在数据竞争问题，`helgrind`工具分析结果如下

```shell
==31766== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

2. 如果只在共享变量`balance`的一个更新周围加锁，仍然存在数据竞争问题；需要在共享变量的两个更新周围都加锁，即

```c
#include "mythreads.h"

int balance = 0;
pthread_mutex_t lock;

void *worker(void *arg) {
    Pthread_mutex_lock(&lock);
    balance++;
    Pthread_mutex_unlock(&lock);
    
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_mutex_init(&lock, NULL);
    pthread_t p;
    Pthread_create(&p, NULL, worker, NULL);

    Pthread_mutex_lock(&lock);
    balance++;
    Pthread_mutex_unlock(&lock);

    Pthread_join(p, NULL);
    pthread_mutex_destroy(&lock);

    return 0;
}
```

`helgrind`工具分析结果表明此时不存在数据竞争问题

```shell
==4407== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 7 from 7)
```

### `main-deadlock`

```c
#include "mythreads.h"
#include <stdio.h>

pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;

void *worker(void *arg) {
    if ((long long)arg == 0) {
        Pthread_mutex_lock(&m1);
        Pthread_mutex_lock(&m2);
    } else {
        Pthread_mutex_lock(&m2);
        Pthread_mutex_lock(&m1);
    }
    Pthread_mutex_unlock(&m1);
    Pthread_mutex_unlock(&m2);

    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p1, p2;
    Pthread_create(&p1, NULL, worker, (void *)(long long)0);
    Pthread_create(&p2, NULL, worker, (void *)(long long)1);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);

    return 0;
}
```

- `helgrind`工具分析结果如下（省略部分与上文重复的内容）

```shell
❯ valgrind --tool=helgrind ./main-deadlock
==7873== ---Thread-Announcement------------------------------------------
==7873== Thread #3 was created
==7873== ----------------------------------------------------------------
==7873== 
==7873== Thread #3: lock order "0x10C040 before 0x10C080" violated
==7873== 
==7873== Observed (incorrect) order is: acquisition of lock at 0x10C080
==7873==    at 0x4853D81: mutex_lock_WRK (hg_intercepts.c:944)
==7873==    by 0x4858FBF: pthread_mutex_lock (hg_intercepts.c:960)
==7873==    by 0x1093A6: Pthread_mutex_lock (mythreads.h:23)
==7873==    by 0x109639: worker (main-deadlock.c:16)
==7873==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==7873==    by 0x4906AC2: start_thread (pthread_create.c:442)
==7873==    by 0x4997A03: clone (clone.S:100)
==7873== 
==7873==  followed by a later acquisition of lock at 0x10C040
==7873==    at 0x4853D81: mutex_lock_WRK (hg_intercepts.c:944)
==7873==    by 0x4858FBF: pthread_mutex_lock (hg_intercepts.c:960)
==7873==    by 0x1093A6: Pthread_mutex_lock (mythreads.h:23)
==7873==    by 0x109648: worker (main-deadlock.c:17)
==7873==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==7873==    by 0x4906AC2: start_thread (pthread_create.c:442)
==7873==    by 0x4997A03: clone (clone.S:100)
==7873== 
==7873== Required order was established by acquisition of lock at 0x10C040
==7873==    at 0x4853D81: mutex_lock_WRK (hg_intercepts.c:944)
==7873==    by 0x4858FBF: pthread_mutex_lock (hg_intercepts.c:960)
==7873==    by 0x1093A6: Pthread_mutex_lock (mythreads.h:23)
==7873==    by 0x109619: worker (main-deadlock.c:13)
==7873==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==7873==    by 0x4906AC2: start_thread (pthread_create.c:442)
==7873==    by 0x4997A03: clone (clone.S:100)
==7873== 
==7873==  followed by a later acquisition of lock at 0x10C080
==7873==    at 0x4853D81: mutex_lock_WRK (hg_intercepts.c:944)
==7873==    by 0x4858FBF: pthread_mutex_lock (hg_intercepts.c:960)
==7873==    by 0x1093A6: Pthread_mutex_lock (mythreads.h:23)
==7873==    by 0x109628: worker (main-deadlock.c:14)
==7873==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==7873==    by 0x4906AC2: start_thread (pthread_create.c:442)
==7873==    by 0x4997A03: clone (clone.S:100)
==7873== 
==7873==  Lock at 0x10C040 was first observed
==7873==    at 0x4853D81: mutex_lock_WRK (hg_intercepts.c:944)
==7873==    by 0x4858FBF: pthread_mutex_lock (hg_intercepts.c:960)
==7873==    by 0x1093A6: Pthread_mutex_lock (mythreads.h:23)
==7873==    by 0x109619: worker (main-deadlock.c:13)
==7873==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==7873==    by 0x4906AC2: start_thread (pthread_create.c:442)
==7873==    by 0x4997A03: clone (clone.S:100)
==7873==  Address 0x10c040 is 0 bytes inside data symbol "m1"
==7873== 
==7873==  Lock at 0x10C080 was first observed
==7873==    at 0x4853D81: mutex_lock_WRK (hg_intercepts.c:944)
==7873==    by 0x4858FBF: pthread_mutex_lock (hg_intercepts.c:960)
==7873==    by 0x1093A6: Pthread_mutex_lock (mythreads.h:23)
==7873==    by 0x109628: worker (main-deadlock.c:14)
==7873==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==7873==    by 0x4906AC2: start_thread (pthread_create.c:442)
==7873==    by 0x4997A03: clone (clone.S:100)
==7873==  Address 0x10c080 is 0 bytes inside data symbol "m2"
==7873== 
==7873== 
==7873== 
==7873== Use --history-level=approx or =none to gain increased speed, at
==7873== the cost of reduced accuracy of conflicting-access information
==7873== For lists of detected and suppressed errors, rerun with: -s
==7873== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 7 from 7)
```

提示信息表明线程#3违反了锁的顺序，即违反了先获取地址 `0x10C040` 的锁，再获取地址 `0x10C080` 的锁的规则。通过阅读源代码`main-deadlock.c`也可以发现**死锁**问题。

`worker`函数中的锁顺序依赖于传入的参数，导致存在一个潜在的死锁情况：

如果线程 p1（参数为 0）获得了`m1`锁，并且线程 p2（参数为 1）同时获得了`m2`锁，那么两个线程都会阻塞在尝试获取第二个锁的操作上：线程 p1 在等待 m2 锁，而线程 p2 在等待 m1 锁。由于每个线程持有另一个线程需要的锁，并且都不释放自己的锁，因此它们都无法继续执行，从而造成死锁。

要解决这个问题，可以确保所有线程以相同的顺序获取锁，或者使用其它同步机制来避免这种锁顺序依赖。

### `main-deadlock-global`

```c
#include "mythreads.h"
#include <stdio.h>

pthread_mutex_t g = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;

void *worker(void *arg) {
    Pthread_mutex_lock(&g);
    if ((long long)arg == 0) {
        Pthread_mutex_lock(&m1);
        Pthread_mutex_lock(&m2);
    } else {
        Pthread_mutex_lock(&m2);
        Pthread_mutex_lock(&m1);
    }
    Pthread_mutex_unlock(&m1);
    Pthread_mutex_unlock(&m2);
    Pthread_mutex_unlock(&g);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p1, p2;
    Pthread_create(&p1, NULL, worker, (void *)(long long)0);
    Pthread_create(&p2, NULL, worker, (void *)(long long)1);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);
    return 0;
}
```

`main-deadlock-global.c`程序中使用了全局互斥锁解决死锁问题。具体分析如下：

在`worker`函数的开始，所有线程都会尝试获取全局互斥锁`g`。这意味着在任何线程可以继续执行并尝试获取其它锁之前，它们必须先获取这个全局锁，在任何给定时间，只有一个线程可以持有`g`，因此只有一个线程可以进入临界区并尝试获取其它锁。即使线程在获取`m1`和`m2`的顺序上有所不同，由于它们是在持有`g`的情况下进行操作，所以不会发生死锁。这是因为持有`g`的线程已经确保了在它尝试获取其它锁时，没有其它线程可以持有这些锁。

但是`helgrind`工具分析结果显示

```shell
Thread #3: lock order "0x10C080 before 0x10C0C0" violated
...
==20204== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 7 from 7)
```

`helgrind`发生了误报，说明`helgrind`这种工具在锁顺序方面采取了保守的策略，会提示一些并非真正错误的警告，从而确保程序的安全性。

### `main-signal`

```c
#include "mythreads.h"
#include <stdio.h>

int done = 0;

void *worker(void *arg) {
    printf("this should print first\n");
    done = 1;

    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    Pthread_create(&p, NULL, worker, NULL);
    while (done == 0)
        ;
    printf("this should print last\n");

    return 0;
}
```

`main-sginal.c`程序创建了一个子线程#2，该线程执行`worker`函数，该函数打印一条消息，并将全局变量`done`设置为1。主线程在`while`循环中等待`done`变为1，然后打印另一条消息。

- `helgrind`工具分析结果如下（省略部分与上文重复的内容）

```shell
❯ valgrind --tool=helgrind ./main-signal
==27862== Command: ./main-signal
==27862== 
this should print first
==27862== ---Thread-Announcement------------------------------------------
==27862== 
==27862== Thread #2 was created
==27862== 
==27862== ---Thread-Announcement------------------------------------------
==27862== 
==27862== Thread #1 is the program's root thread
==27862== 
==27862== ----------------------------------------------------------------
==27862== 
==27862== Possible data race during write of size 4 at 0x10C014 by thread #2
==27862== Locks held: none
==27862==    at 0x109633: worker (main-signal.c:13)
==27862==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==27862==    by 0x4907AC2: start_thread (pthread_create.c:442)
==27862==    by 0x4998A03: clone (clone.S:100)
==27862== 
==27862== This conflicts with a previous read of size 4 by thread #1
==27862== Locks held: none
==27862==    at 0x109684: main (main-signal.c:20)
==27862==  Address 0x10c014 is 0 bytes inside data symbol "done"
==27862== 
==27862== ----------------------------------------------------------------
==27862== 
==27862== Possible data race during read of size 4 at 0x10C014 by thread #1
==27862== Locks held: none
==27862==    at 0x109684: main (main-signal.c:20)
==27862== 
==27862== This conflicts with a previous write of size 4 by thread #2
==27862== Locks held: none
==27862==    at 0x109633: worker (main-signal.c:13)
==27862==    by 0x48574A0: mythread_wrapper (hg_intercepts.c:406)
==27862==    by 0x4907AC2: start_thread (pthread_create.c:442)
==27862==    by 0x4998A03: clone (clone.S:100)
==27862==  Address 0x10c014 is 0 bytes inside data symbol "done"
==27862== 
this should print last
==27862== 
==27862== Use --history-level=approx or =none to gain increased speed, at
==27862== the cost of reduced accuracy of conflicting-access information
==27862== For lists of detected and suppressed errors, rerun with: -s
==27862== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 62 from 35)
```

helgrind报告了两个数据竞争问题：

- **写操作数据竞争**：子线程#2在未持有任何锁的情况下对变量`done`（地址为`0x10C014`）进行了写操作；

- **读操作数据竞争**：主线程#1在未持有任何锁的情况下对变量`done`进行了读操作，与子线程#2的写操作冲突；

程序被编译执行后会先输出`first`后输出`last`，但是helgrind报告数据竞争是因为两个线程都访问了全局变量`done`，而没有适当的同步机制（如互斥锁）来保护这个变量的访问。

---

这段代码效率低下的原因在于主线程使用了一个忙等待循环来检查子线程是否完成了工作。

在`while (done == 0)`循环中，主线程不断地检查`done`变量的值，直到它变为1。即使没有任何有用的计算在进行，CPU也会不断地执行循环，在这期间，CPU周期被浪费在重复检查一个变量的值上，这会导致CPU资源的低效使用。并且在多任务操作系统中，需要重新调度线程以响应其他任务或进程，忙等待循环可能会导致频繁的上下文切换。

可以通过以下几种方法改进：

- 使用条件变量和互斥锁可以让主线程在等待子线程时释放CPU，直到子线程完成工作并通过条件变量通知主线程；

- 使用`pthread_join`函数可以让主线程阻塞，直到子线程完成。这样，主线程就不会在子线程运行时消耗CPU资源；

### `main-signal-cv`

```c
#include "mythreads.h"
#include <stdio.h>

//
// simple synchronizer: allows one thread to wait for another
// structure "synchronizer_t" has all the needed data
// methods are:
//   init (called by one thread)
//   wait (to wait for a thread)
//   done (to indicate thread is done)
//
typedef struct __synchronizer_t {
    pthread_mutex_t lock;
    pthread_cond_t cond;
    int done;
} synchronizer_t;

synchronizer_t s;

void signal_init(synchronizer_t *s) {
    Pthread_mutex_init(&s->lock, NULL);
    Pthread_cond_init(&s->cond, NULL);
    s->done = 0;
}

void signal_done(synchronizer_t *s) {
    Pthread_mutex_lock(&s->lock);
    s->done = 1;
    Pthread_cond_signal(&s->cond);
    Pthread_mutex_unlock(&s->lock);
}

void signal_wait(synchronizer_t *s) {
    Pthread_mutex_lock(&s->lock);
    while (s->done == 0)
        Pthread_cond_wait(&s->cond, &s->lock);
    Pthread_mutex_unlock(&s->lock);
}

void *worker(void *arg) {
    printf("this should print first\n");
    signal_done(&s);

    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    signal_init(&s);
    Pthread_create(&p, NULL, worker, NULL);
    signal_wait(&s);
    printf("this should print last\n");

    return 0;
}
```

- `signal_init`函数初始化互斥锁和条件变量，并将`done`标志设置为0。

- `signal_done`函数设置`done`标志为1，并通过条件变量`cond`发送信号，通知正在等待的线程。互斥锁在发送条件变量信号之前被获取，并在之后释放，这保证了`done`标志的设置与条件变量的信号通知是原子操作。

- `signal_wait`函数使用`Pthread_cond_wait`，它会在等待条件变量时自动释放互斥锁，并在被唤醒时重新获取互斥锁。这避免了死锁，并确保了线程在检查`done`标志之前有互斥锁。

---

- `helgrind`工具分析结果如下（省略部分与上文重复的内容）

```shell
❯ valgrind --tool=helgrind ./main-signal-cv
==36705== Command: ./main-signal-cv
==36705== 
this should print first
this should print last
==36705== 
==36705== Use --history-level=approx or =none to gain increased speed, at
==36705== the cost of reduced accuracy of conflicting-access information
==36705== For lists of detected and suppressed errors, rerun with: -s
==36705== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 7 from 7)
```

说明使用**条件变量**和**互斥锁**之后不再有数据竞争的问题。并且主线程在等待子线程时释放CPU，直到子线程完成工作并通过条件变量通知主线程，节省了CPU资源，程序的性能相较于`main-signal`更高。

## 参考资料

[C语言多线程编程](https://www.cnblogs.com/klelee/p/c_thread.html)

