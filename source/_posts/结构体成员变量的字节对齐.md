---
title: 结构体成员变量的字节对齐
tags:
  - 结构体
categories: 编程
mathjax: true
abbrlink: ddbc63cd
date: 2024-06-15 22:48:14
---

> - 编译器版本（`MinGW` 及其衍生品，比如 `TDM-GCC` 可能不支持 `#pragma pack(n), n>1`，参见 [mingw-and-packed-struct-alignment-using-c11](https://stackoverflow.com/questions/20144145/mingw-and-packed-struct-alignment-using-c11)）
>
> ```shell
> ❯ gcc --version
> gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
> Copyright (C) 2021 Free Software Foundation, Inc.
> This is free software; see the source for copying conditions.  There is NO
> warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
> ```
>
> - 本文讨论的对齐属性
>
> ```c
> #pragma pack(n)
> __attribute__((packed));
> __attribute__((aligned(8)));
> ```
>
> - 完整验证代码见文末
> - 在 Linux 环境下 `char` 占 $1$ 字节，`int` 占 $4$ 字节，`short` 占 $2$ 字节，`long long` 占 $8$ 字节（`long` 占 $4$ 字节($32$ 位)，$8$ 字节($64$ 位)）

## 实验 1

> 无全局的 `#pragma pack(n)`

实验结果如下

```c
struct test {     // size = 15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((packed));

struct test1 {    // size = 20    \  size = 24
    char x2;      // 4 = 1 + 3
    int x1;       // 4
    short x3;     // 4 = 2 + 2  \ 8 = 2 + 6
    long long x4; // 8
};

struct test2 {    // size = 24     \  size = 24
    char x2;      // 4 = 1 + 3
    int x1;       // 4
    short x3;     // 4 = 2 + 2   \ 8 = 2 + 6
    long long x4; // 8 + 4       \ 8
} __attribute__((aligned(8)));
```

注释中所标注的是结构体中每个成员变量所占内存空间的大小（如 $32$ 位与 $64$ 位结果不同，左侧为 $32$ 位下运行结果）

- **test**：`__attribute__((packed))` 取消字节对齐，所有成员紧凑排列；
- **test1**：$32$ 系统中，默认 $4$ 字节对齐，则 `char` 后填充 $3$ 字节，`short` 后填充 $2$ 字节，总共占 $20$ 字节；$64$ 位系统中，为了保证 `long long` $8$ 字节对齐，要在 `short` 后填充 $6$ 字节，总共占 $24$ 字节；
- **test2**：`__attribute__((aligned(8)));` 要求 `test2` 的起始地址是 $8$ 的倍数。
  - $32$ 位系统中，按照 `test1`，结构体总共占 $20$ 字节。但考虑连续实例化 `test2` 的情况，第一个起始地址是 $8$ 的倍数，占 $20$ 字节，下一个的起始地址就不再是 $8$ 的倍数，因此需要在末尾再填充 $4$ 字节，总共占用 $24$ 字节；
    - $64$ 位系统中，按照 `test1`，结构体总共占 $24$ 字节。可以满足再实例化的结构体起始地址是 $8$ 的倍数，不需要在末尾额外填充，总共占用 $24$ 字节；

## 实验 2

> ```c
> #pragma pack(1)
> ```

实验结果如下

```c
struct test {     // size = 15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((packed));

struct test1 {    // size = 15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
};

struct test2 {    // size = 16
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((aligned(8)));
```

全局的 `#pragma pack(1)` 表示默认紧凑排列，所以 `test` 和 `test1` 均占用 `15` 字节。

`test2` 中 `__attribute__((aligned(8)));` 要求起始地址 $8$ 字节对齐，需要在末尾额外填充 $16-15=1$ 字节，总共占 $16$ 字节。

## 实验 3

> ```c
> #pragma pack(2)
> ```

实验结果如下

```c
struct test {     // size = 15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((packed));
struct test1 {    // size = 16
    char x2;      // 2 = 1 + 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
};
struct test2 {    // size = 16
    char x2;      // 2
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((aligned(8)));
```

全局的 `#pragma pack(2)` 表示默认按 $2$ 字节对齐排列，

- **test**：`__attribute__((packed))` 取消字节对齐，所有成员紧凑排列；
- **test1**：按 $2$ 字节对齐，则 `char` 后需填充 $1$ 字节，总共占 $16$ 字节；
- **test2**：按 `test1`，总共占 $16$ 字节，可以满足再实例化的结构体起始地址是 $8$ 的倍数，不需要在末尾额外填充，总共占 $16$ 字节；

## 附录：完整实验代码

```c
#include <stddef.h>
#include <stdio.h>

// 1. Unrestrained
// 2. #pragma pack(1)
// 3. #pragma pack(2)

struct test {
    char x2;
    int x1;
    short x3;
    long long x4;
} __attribute__((packed));

struct test1 {
    char x2;
    int x1;
    short x3;
    long long x4;
};

struct test2 {
    char x2;
    int x1;
    short x3;
    long long x4;
} __attribute__((aligned(8)));

int main() {
    struct test t;
    printf("%zu, addr_x2=%p\n", offsetof(struct test, x2), &t.x2);
    printf("%zu, addr_x1=%p\n", offsetof(struct test, x1), &t.x1);
    printf("%zu, addr_x3=%p\n", offsetof(struct test, x3), &t.x3);
    printf("%zu, addr_x4=%p\n", offsetof(struct test, x4), &t.x4);
    printf("%zu\n", sizeof(struct test));

    printf("******\n");

    struct test1 t1;
    printf("%zu, addr_x2=%p\n", offsetof(struct test1, x2), &t1.x2);
    printf("%zu, addr_x1=%p\n", offsetof(struct test1, x1), &t1.x1);
    printf("%zu, addr_x3=%p\n", offsetof(struct test1, x3), &t1.x3);
    printf("%zu, addr_x4=%p\n", offsetof(struct test1, x4), &t1.x4);
    printf("%zu\n", sizeof(struct test1));

    printf("******\n");

    struct test2 t2;
    printf("%zu, addr_x2=%p\n", offsetof(struct test2, x2), &t2.x2);
    printf("%zu, addr_x1=%p\n", offsetof(struct test2, x1), &t2.x1);
    printf("%zu, addr_x3=%p\n", offsetof(struct test2, x3), &t2.x3);
    printf("%zu, addr_x4=%p\n", offsetof(struct test2, x4), &t2.x4);
    printf("%zu\n", sizeof(struct test2));

    return 0;
}
```
