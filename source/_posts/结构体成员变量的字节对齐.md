---
title: 结构体成员变量的字节对齐
tags:
  - 结构体
categories: 编程
mathjax: true
abbrlink: ddbc63cd
date: 2024-06-15 22:48:14
---

# 结构体成员变量的字节对齐

> - 编译器版本（`MinGW`及其衍生品，比如`TDM-GCC`可能不支持`#pragma pack(n), n>1`，参见[mingw-and-packed-struct-alignment-using-c11](https://stackoverflow.com/questions/20144145/mingw-and-packed-struct-alignment-using-c11)）
>
> ```shell
> ❯ gcc --version
> gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
> Copyright (C) 2021 Free Software Foundation, Inc.
> This is free software; see the source for copying conditions.  There is NO
> warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
> ```
>
> - 本文讨论的对齐属性
>
> ```c
> #pragma pack(n)
> __attribute__((packed));
> __attribute__((aligned(8)));
> ```
>
> - 完整验证代码见文末
> - 在Linux环境下`char`占$1$字节，`int`占$4$字节，`short`占$2$字节，`long long`占$8$字节（`long`占$4$字节($32$位)，$8$字节($64$位)）

## 实验1

> 无全局的`#pragma pack(n)`

实验结果如下

```c
struct test {     // size=15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((packed));

struct test1 {    // size=20    \  size=24
    char x2;      // 4 = 1 + 3
    int x1;       // 4
    short x3;     // 4 = 2 + 2  \ 8 = 2 + 6
    long long x4; // 8
};

struct test2 {    // size=24     \  size=24
    char x2;      // 4 = 1 + 3
    int x1;       // 4
    short x3;     // 4 = 2 + 2   \ 8 = 2 + 6
    long long x4; // 8 + 4       \ 8
} __attribute__((aligned(8)));
```

注释中所标注的是结构体中每个成员变量所占内存空间的大小（如$32$位与$64$位结果不同，左侧为$32$位下运行结果）

- **test**：`__attribute__((packed))`取消字节对齐，所有成员紧凑排列；
- **test1**：$32$系统中，默认$4$字节对齐，则`char`后填充$3$字节，`short`后填充$2$字节，总共占$20$字节；$64$位系统中，为了保证`long long`$8$字节对齐，要在`short`后填充$6$字节，总共占$24$字节；
- **test2**：`__attribute__((aligned(8)));`要求`test2`的起始地址是$8$的倍数。
    - $32$位系统中，按照`test1`，结构体总共占$20$字节。但考虑连续实例化`test2`的情况，第一个起始地址是$8$的倍数，占$20$字节，下一个的起始地址就不再是$8$的倍数，因此需要在末尾再填充$4$字节，总共占用$24$字节；
    - $64$位系统中，按照`test1`，结构体总共占$24$字节。可以满足再实例化的结构体起始地址是$8$的倍数，不需要在末尾额外填充，总共占用$24$字节；

## 实验2

> ```c
> #pragma pack(1)
> ```

实验结果如下

```c
struct test {     // size=15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((packed));

struct test1 {    // size=15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
};

struct test2 {    // size=16
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((aligned(8)));
```

全局的`#pragma pack(1)`表示默认紧凑排列，所以`test`和`test1`均占用`15`字节。

`test2`中`__attribute__((aligned(8)));`要求起始地址$8$字节对齐，需要在末尾额外填充$16-15=1$字节，总共占$16$字节。

## 实验3

> ```c
> #pragma pack(2)
> ```

实验结果如下

```c
struct test {     // size=15
    char x2;      // 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((packed));
struct test1 {    // size=16
    char x2;      // 2 = 1 + 1
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
};
struct test2 {    // size=16
    char x2;      // 2
    int x1;       // 4
    short x3;     // 2
    long long x4; // 8
} __attribute__((aligned(8)));
```

全局的`#pragma pack(2)`表示默认按$2$字节对齐排列，

- **test**：`__attribute__((packed))`取消字节对齐，所有成员紧凑排列；
- **test1**：按$2$字节对齐，则`char`后需填充$1$字节，总共占$16$字节；
- **test2**：按`test1`，总共占$16$字节，可以满足再实例化的结构体起始地址是$8$的倍数，不需要在末尾额外填充，总共占$16$字节；

## 附录：完整实验代码

```c
#include <stddef.h>
#include <stdio.h>

// 1. Unrestrained
// 2. #pragma pack(1)
// 3. #pragma pack(2)

struct test {
    char x2;
    int x1;
    short x3;
    long long x4;
} __attribute__((packed));

struct test1 {
    char x2;
    int x1;
    short x3;
    long long x4;
};

struct test2 {
    char x2;
    int x1;
    short x3;
    long long x4;
} __attribute__((aligned(8)));

int main() {
    struct test t;
    printf("%zu, addr_x2=%p\n", offsetof(struct test, x2), &t.x2);
    printf("%zu, addr_x1=%p\n", offsetof(struct test, x1), &t.x1);
    printf("%zu, addr_x3=%p\n", offsetof(struct test, x3), &t.x3);
    printf("%zu, addr_x4=%p\n", offsetof(struct test, x4), &t.x4);
    printf("%zu\n", sizeof(struct test));

    printf("******\n");

    struct test1 t1;
    printf("%zu, addr_x2=%p\n", offsetof(struct test1, x2), &t1.x2);
    printf("%zu, addr_x1=%p\n", offsetof(struct test1, x1), &t1.x1);
    printf("%zu, addr_x3=%p\n", offsetof(struct test1, x3), &t1.x3);
    printf("%zu, addr_x4=%p\n", offsetof(struct test1, x4), &t1.x4);
    printf("%zu\n", sizeof(struct test1));

    printf("******\n");

    struct test2 t2;
    printf("%zu, addr_x2=%p\n", offsetof(struct test2, x2), &t2.x2);
    printf("%zu, addr_x1=%p\n", offsetof(struct test2, x1), &t2.x1);
    printf("%zu, addr_x3=%p\n", offsetof(struct test2, x3), &t2.x3);
    printf("%zu, addr_x4=%p\n", offsetof(struct test2, x4), &t2.x4);
    printf("%zu\n", sizeof(struct test2));

    return 0;
}
```

