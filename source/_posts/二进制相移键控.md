---
title: 二进制相移键控
tags:
  - BPSK
  - 采样定理
categories: 通信
mathjax: true
abbrlink: b29ce584
date: 2024-07-20 19:15:33
---

## 基础

**BPSK** 的时域表达式是

$$
e_{BPSK}(t) = \sum_{n = -\infty}^{+\infty} a_nh(t-nT_S)\cos(\omega_ct+\varphi)
$$

- $a_n$：待发送的二进制信息
- $T_S$：符号周期
- $h(t)$：成型滤波器的冲激响应
- $\omega_c$：载波中心频率

> $T_S\sim N\dfrac{2\pi}{\omega_c}$：未必整数倍

## MATLAB 仿真

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk.webp" width="90%" height="75%" />

按照上图流程进行 MATLAB 仿真

### 调制与解调

> 设定参数：系统时钟频率为 $160MHz$，根升余弦滤波器滚降系数 $\alpha=0.35$，其它参数可修改
>
> ```matlab
> sys_clk = 160e6;
> Rb = 5e6;                  % //FIXME
> Rs = Rb; Ts = 1 / Rs;
>
> usmp_rate = sys_clk / Rs;  % //FIXME
> fc = 20e6;                 % //FIXME
> hrc = 'rrc';               % //FIXME
> ```

1. 随机生成 `num` 个二进制数，并对极化处理：

```matlab
num = round(100000 * 10 ^ (EbNo / 10));
b = randi([0 1], 1, num);
b_sign = 1 - 2 * b;
% b_sign = exp(1j * pi * b)  % 1: cos(-\pi)=-1 / 0: cos(\pi)=1
```

2. 成型滤波，并去除延迟：

```matlab
switch hrc
    case 'rect'
        h = ones(1, usmp_rate + 1);
    case 'sinc'
        t = -3 * pi : pi / usmp_rate : 3 * pi;
        h = sinc(t);
    case 'rrc'
        beta = 0.35;
        span = 6;
        sps = usmp_rate;
        h = rcosdesign(beta, span, sps, 'sqrt');
end

baseband = conv(upsample(b_sign, usmp_rate), h);
delay = (length(h) - 1 ) / 2;
baseband = baseband(delay + 1:end - delay);
```

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_baseband.webp" width="100%" height="75%" />

<center> <small> 基带信号的时域波形与功率谱密度 </small> </center>

3. 载波调制

```matlab
phase = 2 * pi * rand;
total_t = Ts * num;
t = 0 : 1/sys_clk : (total_t - 1/sys_clk);
carrier = cos(2 * pi * fc * t + phase);
modulated_signal = baseband .* carrier;
```

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_modulated.webp" width="100%" height="75%" />

<center> <small> 调制信号的时域波形与功率谱密度 </small> </center>

---

0. 经过高斯白噪声信道

> $SNR$ 与 $E_b/n_0$ 的关系：
>
> $$
> SNR = \dfrac{S}{N} = \dfrac{E_b}{n_0}\dfrac{R_b}{B}
> $$

```matlab
SNR = EbNo - 10 * log10(usmp_rate / 2);
noised_signal = awgn(modulated_signal, SNR, 'measured');
```

1. 相干解调

```matlab
local_carrier = 2 * carrier;
received_signal = noised_signal .* local_carrier;
```

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_received.webp" width="100%" height="75%" />

<center> <small> 相干解调信号的时域波形与功率谱密度 </small> </center>

2. 匹配滤波与抽样判决

```matlab
mf_dout = conv(received_signal, fliplr(h));
delay = (length(h) - 1) / 2;
decision_result = downsample(mf_dout(delay+1:end), usmp_rate);
decision_result = decision_result(1:num);
```

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_mf_dout.webp" width="100%" height="75%" />

<center> <small> 匹配滤波后信号的时域波形与功率谱密度 </small> </center>

### 仿真结果

将仿真得到的误比特率曲线与理论误比特率曲线比较，基本重合

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_ber.webp" width="90%" height="75%" />

### 理论分析

#### 载波频率对误比特率的影响

> 带通采样定理：
>
> <img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/nyquist.webp" width="75%" height="75%" />
>
> 频带信号如图所示，为了保证被采样后不会发生混叠，需要满足条件：
>
> $$
> \left\{
> \begin{aligned}
> &-f_L + mf_s \leq f_L\\
> &-f_H + (m+1)f_s \geq f_H\\
> \end{aligned}
> \right.
> $$
>
> 则
>
> $$
> \dfrac{2f_H}{m+1} \leq f_s \leq \dfrac{2f_L}{m}
> $$

在采样频率、码元速率一定时，由带通采样定理可以推导出载波频率 $f_c$ 的范围：

$$
\begin{aligned}
&\dfrac{2f_H}{m+1} \leq f_s \leq \dfrac{2f_L}{m}\\
&(f_H = f_c + \dfrac{B}{2}, f_L = f_c - \dfrac{B}{2})\\
&\dfrac{m}{2}f_s + \dfrac{B}{2}\leq f_c \leq \dfrac{m+1}{2}f_s - \dfrac{B}{2}\\
&(B = \dfrac{R_S}{\frac{2}{1+\alpha}}\times 2)\\
&\dfrac{m}{2}f_s + \dfrac{R_S(1+\alpha)}{2}\leq f_c \leq \dfrac{m+1}{2}f_s - \dfrac{R_S(1+\alpha)}{2}\\
\end{aligned}
$$

当 $f_s = 160MHz, \alpha=0.35, R_S = 5MHz$ 时，可以得到 **载波频率的取值范围** 是

$$
\begin{aligned}
&m = 0, \quad 3.375 < f_c < 76.625\\
&m = 1, \quad 83.375 < f_c < 156.625\\
&m = 2, \quad 163.375 < f_c < 236.625\\
&\cdots
\end{aligned}
$$

#### 内插系数对误比特率的影响

$$
\begin{aligned}
&R_S \leq \dfrac{2f_c - mf_s}{1+\alpha}\\
&R_S \leq \dfrac{(m+1)f_s - 2f_c}{1+\alpha}\\
\end{aligned}
$$

当 $f_s = 160, \alpha =0.35, f_c = 20$ 时，可以得到内插系数的范围是

$$
\left\{
\begin{aligned}
&2f_c - m f_s > 0\\
&(m+1)f_s - 2f_c > 0\\
\end{aligned}
\right. \Rightarrow m = 0\\
R_S \leq \dfrac{40}{1.35}\Rightarrow UsmpRate\geq 5.4\\
$$

#### 接收机采样点位置对误比特率的影响

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_decision_point.webp" width="90%" height="75%" />

由仿真结果可以看出，在最佳的接收机采样点处采样，误比特率最低，距离该点越远，误比特率越高。

#### 成型滤波器对误比特率的影响

几乎无影响。

## FPGA 仿真（调制）

> 设定参数：系统时钟频率为 $160MHz$，传输速率 $R_b=5MHz$，发送比特数为 $1024$ 位。

```verilog
reg [14:0] counter = 15'd0;
always @(posedge clk) begin
    if (!rst_n) begin
        counter[14:0] <= 13'd0;
    end
    else begin
        counter[14:0] <= counter[14:0] + 13'd1;
    end
end

wire [9:0] address;
// sys_clk = 160M / Rb = 5M = 32
assign address[9:0] = counter[14:5];
```

由系统时钟频率和传输速率可以得到内插系数为 $32$，需要 $5$ 位计数器；发送 $1024$ 位数据，需要 $10$ 位地址，于是定义计数器变量为 `reg [14:0] counter`，每计数 $32$，地址增 $1$，将 `counter` 的高 $10$ 位赋值给 $address$.

存储数据、成型滤波、载波调制等过程通过 IP 核实现：

|     功能     |          IP 核           |
| :----------: | :----------------------: |
|   存储数据   | `Block Memory Generator` |
|   成型滤波   |      `FIR Compiler`      |
|   生成载波   |      `DDS Compiler`      |
|   载波调制   |       `Multiplier`       |
| 生成系统时钟 |      `Clock Wizard`      |

仿真波形如下图

<img src="https://cdn.jsdelivr.net/gh/Euler0525/tube@master/ct/bpsk_FPGA.webp" width="100%" height="75%" />

## 附录

- MATLAB 仿真代码（CPU 版）

```matlab
close all; clear; clc;

tic;

% FIXME System Parameters
fs = 122.88e6;
Rs = 3.072e6;
Rb = Rs; Ts = 1 / Rs;
fc = 2e9;

usmp_rate = floor(fs / Rs);

num = 5000;
b = 1 - 2 * randi([0 1], 1, num);

%% Send
beta = 0.1; span = 12;
sps = usmp_rate;
h = rcosdesign(beta, span, sps, "sqrt");

baseband_tx = conv(upsample(b, usmp_rate), h, "same");

toc;

t = (1 : length(baseband_tx)) / fs;
carrier = cos(2 * pi * fc * t);
tx_wave = baseband_tx .* carrier;

toc;

%% Channel
Ebn0_dB = 10;
SNR_dB = Ebn0_dB - 10 * log10(usmp_rate / 2);
rx_wave = awgn(tx_wave, SNR_dB, 'measured');

toc;

%% Recv
% Coherent Demodulation
local_carrier = 2 * carrier;
demod_wave = rx_wave .* local_carrier;

% Matched Filtering
baseband_rx = conv(demod_wave, h, "same");

% Sampling and Decision
samples = baseband_rx(1 : sps : end);
bits_recovered = double(samples < 0);

toc;

original_bits = (b < 0);
err = sum(original_bits(1:num) ~= bits_recovered(1:num));
fprintf('Bit error rate: %d\n', err / num);

%% Figure
N = 65536;
t = (1 : length(baseband_tx)) / fs;
% Send
figure;
subplot(2, 1, 1);
plot(t, baseband_tx);
xlabel("Time (s)"); ylabel("Amplitude");
title("BPSK Baseband Signal");
grid on;

subplot(2, 1, 2);
f = (-fs/2 : fs/N : fs/2-fs/N);
plot(f, 10 * log10(abs(fftshift(fft(baseband_tx, N)))));
xlabel("Frequency (Hz)"); ylabel("Amplitude (dB)");
title("BPSK Baseband Spectrum");
grid on;

% Recv
figure;
subplot(2, 2, 1);
plot(t, demod_wave);
xlabel("Time (s)"); ylabel("Amplitude");
title("Coherent Demodulation Signal");
grid on;

subplot(2, 2, 2);
plot(t, baseband_rx);
xlabel("Time (s)"); ylabel("Amplitude");
title("Matched Filtering Signal");
grid on;

subplot(2, 2, 3);
f = (-fs/2 : fs/N : fs/2-fs/N);
plot(f, 10 * log10(abs(fftshift(fft(demod_wave, N)))));
xlabel("Frequency (Hz)"); ylabel("Amplitude (dB)");
title("Coherent Demodulation Spectrum");
grid on;

subplot(2, 2, 4);
f = (-fs/2 : fs/N : fs/2-fs/N);
plot(f, 10 * log10(abs(fftshift(fft(baseband_rx, N)))));
xlabel("Frequency (Hz)"); ylabel("Amplitude (dB)");
title("Matched Filtering Spectrum");
grid on;

figure;
subplot(2, 1, 1);
plot(original_bits(1:100));
hold on;
stem(original_bits(1:100), "r", "LineStyle", "none", "Marker", "o");
title('Original Bits (First 100)');
subplot(2, 1, 2);
plot(bits_recovered(1:100));
hold on;
stem(bits_recovered(1:100), "r", "LineStyle", "none", "Marker", "o");
title('Recovered Bits (First 100)');
```

- MATLAB 仿真代码（GPU 版）

```matlab
close all; clear; clc;

if gpuDeviceCount > 0
    gpuDevice(1);
    fprintf('Using GPU: %s\n', gpuDevice().Name);
else
    error('No GPU detected!');
end

tic;

% FIXME System Parameters
fs = 122.88e6;
Rs = 3.072e6;
Rb = Rs; Ts = 1 / Rs;
% fc = 2e9;

usmp_rate = floor(fs / Rs);

num = 10000000;
b = gpuArray(1 - 2 * randi([0 1], 1, num));

%% Send
beta = 0.1; span = 12;
sps = usmp_rate;
h = gpuArray(rcosdesign(beta, span, sps, "sqrt"));

baseband_tx = conv(upsample(b, usmp_rate), h, "same");

toc;

% t = (1 : length(baseband_tx)) / fs;
% carrier = cos(2 * pi * fc * t);
% tx_wave = baseband_tx .* carrier;
%
% toc;

%% Channel
Ebn0_dB = 10;
SNR_dB = Ebn0_dB - 10 * log10(usmp_rate / 2);
signal_power = mean(abs(baseband_tx).^2);
noise_power = signal_power / (10^(SNR_dB/10));
noise = sqrt(noise_power) * randn(size(baseband_tx), 'gpuArray');
rx_wave = baseband_tx + noise;

toc;

%% Recv
% % Coherent Demodulation
% local_carrier = 2 * carrier;
% demod_wave = rx_wave .* local_carrier;

% Matched Filtering
baseband_rx = conv(rx_wave, h, "same");

% Sampling and Decision
samples = baseband_rx(1 : sps : end);
bits_recovered = double(samples < 0);

toc;

original_bits = (b < 0);
bits_recovered = gather(bits_recovered);
baseband_tx = gather(baseband_tx);
baseband_rx = gather(baseband_rx);
err = sum(original_bits(1:num) ~= bits_recovered(1:num));
fprintf('Bit error rate: %d\n', err / num);

%% Figure
N = 65536;
t = (1 : length(baseband_tx)) / fs;
% Send
figure;
subplot(2, 1, 1);
plot(t, baseband_tx);
xlabel("Time (s)"); ylabel("Amplitude");
title("BPSK Baseband Signal");
grid on;

subplot(2, 1, 2);
f = (-fs/2 : fs/N : fs/2-fs/N);
plot(f, 10 * log10(abs(fftshift(fft(baseband_tx, N)))));
xlabel("Frequency (Hz)"); ylabel("Amplitude (dB)");
title("BPSK Baseband Spectrum");
grid on;

% Recv
figure;
% subplot(2, 2, 1);
% plot(t, demod_wave);
% xlabel("Time (s)"); ylabel("Amplitude");
% title("Coherent Demodulation Signal");
% grid on;

subplot(2, 1, 1);
plot(t, baseband_rx);
xlabel("Time (s)"); ylabel("Amplitude");
title("Matched Filtering Signal");
grid on;

% subplot(2, 2, 3);
% f = (-fs/2 : fs/N : fs/2-fs/N);
% plot(f, 10 * log10(abs(fftshift(fft(demod_wave, N)))));
% xlabel("Frequency (Hz)"); ylabel("Amplitude (dB)");
% title("Coherent Demodulation Spectrum");
% grid on;

subplot(2, 1, 2);
f = (-fs/2 : fs/N : fs/2-fs/N);
plot(f, 10 * log10(abs(fftshift(fft(baseband_rx, N)))));
xlabel("Frequency (Hz)"); ylabel("Amplitude (dB)");
title("Matched Filtering Spectrum");
grid on;

figure;
subplot(2, 1, 1);
plot(original_bits(1:100));
hold on;
stem(original_bits(1:100), "r", "LineStyle", "none", "Marker", "o");
title('Original Bits (First 100)');
subplot(2, 1, 2);
plot(bits_recovered(1:100));
hold on;
stem(bits_recovered(1:100), "r", "LineStyle", "none", "Marker", "o");
title('Recovered Bits (First 100)');
```

## 参考资料

[Euler0525/bpsk-gpu](https://github.com/Euler0525/bpsk-gpu/tree/develop)
