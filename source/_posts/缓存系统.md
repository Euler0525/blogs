---
title: 缓存系统
tags:
  - LRU
categories: 编程
mathjax: true
abbrlink: f86252e2
date: 2025-07-16 14:04:34
---

# 缓存系统

## 最久未使用缓存机制

最久未使用(Least Recently Used, LRU)缓存机制，将最近最少使用的内容替换掉。

- [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

利用**哈希表**和**双向链表**实现LRU缓存机制，使查找、添加和删除都是$O(1)$的操作。

待缓存的内容以键值对`key-value`的形式存在，哈希表存储了已经存在于缓存区的内容的`key`。双向链表的节点按照访问时间排序，越靠近尾部，越久没有被访问。

读取缓存时，只需要在哈希表中查找是否存在`key`，存在则返回对应的`value`，同时，这是最新访问的`key-value`，就把它移动到链表头部，如果不存在，就将其直接插入到链表头部。

更新缓存时，直接将`key-value`更新到链表头部即可，如果超出缓存区容量，将尾部节点删除。

```c++
#include <unordered_map>

class LRUCache {
public:
    explicit LRUCache(const int _capacity): capacity(_capacity) {
        dummy_head = new Node();
        dummy_tail = new Node();
        dummy_head->next = dummy_tail;
        dummy_tail->prev = dummy_head;
    }

    int get(const int key) {
        if (keys_mp.find(key) == keys_mp.end()) {
            return -1;
        }
        const int value = keys_mp[key]->value;
        removeFromCache(keys_mp[key]);
        insertToCache(key, value);

        return value;
    }

    void put(const int key, const int value) {
        if (keys_mp.find(key) != keys_mp.end()) {
            removeFromCache(keys_mp[key]);
        }
        insertToCache(key, value);

        if (keys_mp.size() > capacity) {
            keys_mp.erase(dummy_tail->prev->key);
            removeFromCache(dummy_tail->prev);
        }
    }

private:
    int capacity;
    typedef struct Node {
        int key;
        int value;
        Node *prev;
        Node *next;
        Node(): key(0), value(0), prev(nullptr), next(nullptr) {}
        Node(const int _key, const int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
    } Node;

    std::unordered_map<int, Node *> keys_mp;
    Node *dummy_head;
    Node *dummy_tail;

    void insertToCache(const int key, const int value)  {
        const auto node = new Node(key, value);
        keys_mp[key] = node;

        node->next = dummy_head->next;
        node->prev = dummy_head;
        dummy_head->next->prev = node;
        dummy_head->next = node;
    }

    static void removeFromCache(const Node * node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;

        delete node;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

